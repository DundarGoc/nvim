-- Attempt to write useful color scheme functionality:
-- - Implement 'base16' theme in Lua. Sources:
--     - https://github.com/chriskempson/base16/blob/master/styling.md
--     - https://github.com/chriskempson/base16-vim/
-- - Implement 'mini16' theme which should take only two colors: main
--   background and main foreground. Everything else should be autogenerated
--   based on personal heuristics.

-- Module and its helper
local MiniColors = {}
local H = {}

-- Module setup
function MiniColors.setup(config)
  -- Export module
  _G.MiniColors = MiniColors

  vim.cmd([[syntax on]])
end

MiniColors.palette = nil

function MiniColors.base16(palette, name)
  MiniColors.palette = palette

  vim.cmd([[highlight clear]])
  vim.cmd([[syntax reset]])
  vim.g.colors_name = name or 'base16'

  local p = palette

  -- Builtin highlighting groups
  H.hi('Bold',         {guifg='',       guibg='',       gui='bold',      guisp=''})
  H.hi('ColorColumn',  {guifg='',       guibg=p.base01, gui='none',      guisp=''})
  H.hi('Conceal',      {guifg=p.base0D, guibg=p.base00, gui='',          guisp=''})
  H.hi('Cursor',       {guifg=p.base00, guibg=p.base05, gui='',          guisp=''})
  H.hi('CursorColumn', {guifg='',       guibg=p.base01, gui='none',      guisp=''})
  H.hi('CursorLine',   {guifg='',       guibg=p.base01, gui='none',      guisp=''})
  H.hi('CursorLineNr', {guifg=p.base04, guibg=p.base01, gui='',          guisp=''})
  H.hi('Debug',        {guifg=p.base08, guibg='',       gui='',          guisp=''})
  H.hi('DiffAdd',      {guifg=p.base0B, guibg=p.base01, gui='',          guisp=''})
  H.hi('DiffChange',   {guifg=p.base03, guibg=p.base01, gui='',          guisp=''})
  H.hi('DiffDelete',   {guifg=p.base08, guibg=p.base01, gui='',          guisp=''})
  H.hi('DiffText',     {guifg=p.base0D, guibg=p.base01, gui='',          guisp=''})
  H.hi('Directory',    {guifg=p.base0D, guibg='',       gui='',          guisp=''})
  H.hi('Error',        {guifg=p.base00, guibg=p.base08, gui='',          guisp=''})
  H.hi('ErrorMsg',     {guifg=p.base08, guibg=p.base00, gui='',          guisp=''})
  H.hi('Exception',    {guifg=p.base08, guibg='',       gui='',          guisp=''})
  H.hi('FoldColumn',   {guifg=p.base0C, guibg=p.base01, gui='',          guisp=''})
  H.hi('Folded',       {guifg=p.base03, guibg=p.base01, gui='',          guisp=''})
  H.hi('IncSearch',    {guifg=p.base01, guibg=p.base09, gui='none',      guisp=''})
  H.hi('Italic',       {guifg='',       guibg='',       gui='none',      guisp=''})
  H.hi('LineNr',       {guifg=p.base03, guibg=p.base01, gui='',          guisp=''})
  H.hi('Macro',        {guifg=p.base08, guibg='',       gui='',          guisp=''})
  ---- Slight difference from base16, where base03 is used. This makes it
  ---- possible to comfortably see this highlighting in comments.
  H.hi('MatchParen',   {guifg='',       guibg=p.base02, gui='',          guisp=''})
  H.hi('ModeMsg',      {guifg=p.base0B, guibg='',       gui='',          guisp=''})
  H.hi('MoreMsg',      {guifg=p.base0B, guibg='',       gui='',          guisp=''})
  H.hi('NonText',      {guifg=p.base03, guibg='',       gui='',          guisp=''})
  ---- Major difference from base16: using '04' as main foreground
  H.hi('Normal',       {guifg=p.base04, guibg=p.base00, gui='',          guisp=''})
  H.hi('PMenu',        {guifg=p.base05, guibg=p.base01, gui='none',      guisp=''})
  H.hi('PMenuSel',     {guifg=p.base01, guibg=p.base05, gui='',          guisp=''})
  H.hi('Question',     {guifg=p.base0D, guibg='',       gui='',          guisp=''})
  H.hi('QuickFixLine', {guifg='',       guibg=p.base01, gui='none',      guisp=''})
  H.hi('Search',       {guifg=p.base01, guibg=p.base0A, gui='',          guisp=''})
  H.hi('SignColumn',   {guifg=p.base03, guibg=p.base01, gui='',          guisp=''})
  H.hi('SpecialKey',   {guifg=p.base03, guibg='',       gui='',          guisp=''})
  H.hi('SpellBad',     {guifg='',       guibg='',       gui='undercurl', guisp=p.base08})
  H.hi('SpellCap',     {guifg='',       guibg='',       gui='undercurl', guisp=p.base0D})
  H.hi('SpellLocal',   {guifg='',       guibg='',       gui='undercurl', guisp=p.base0C})
  H.hi('SpellRare',    {guifg='',       guibg='',       gui='undercurl', guisp=p.base0E})
  H.hi('StatusLine',   {guifg=p.base04, guibg=p.base02, gui='none',      guisp=''})
  H.hi('StatusLineNC', {guifg=p.base03, guibg=p.base01, gui='none',      guisp=''})
  H.hi('Substitute',   {guifg=p.base01, guibg=p.base0A, gui='none',      guisp=''})
  H.hi('TabLine',      {guifg=p.base03, guibg=p.base01, gui='none',      guisp=''})
  H.hi('TabLineFill',  {guifg=p.base03, guibg=p.base01, gui='none',      guisp=''})
  H.hi('TabLineSel',   {guifg=p.base0B, guibg=p.base01, gui='none',      guisp=''})
  H.hi('Title',        {guifg=p.base0D, guibg='',       gui='none',      guisp=''})
  H.hi('TooLong',      {guifg=p.base08, guibg='',       gui='',          guisp=''})
  H.hi('Underlined',   {guifg=p.base08, guibg='',       gui='',          guisp=''})
  H.hi('VertSplit',    {guifg=p.base02, guibg=p.base02, gui='none',      guisp=''})
  H.hi('Visual',       {guifg='',       guibg=p.base02, gui='',          guisp=''})
  H.hi('VisualNOS',    {guifg=p.base08, guibg='',       gui='',          guisp=''})
  H.hi('WarningMsg',   {guifg=p.base08, guibg='',       gui='',          guisp=''})
  H.hi('WildMenu',     {guifg=p.base08, guibg=p.base0A, gui='',          guisp=''})

  -- Standard syntax (influences treesitter)
  H.hi('Boolean',      {guifg=p.base09, guibg='',       gui='',     guisp=''})
  H.hi('Character',    {guifg=p.base08, guibg='',       gui='',     guisp=''})
  H.hi('Comment',      {guifg=p.base03, guibg='',       gui='',     guisp=''})
  H.hi('Conditional',  {guifg=p.base0E, guibg='',       gui='',     guisp=''})
  H.hi('Constant',     {guifg=p.base09, guibg='',       gui='',     guisp=''})
  H.hi('Define',       {guifg=p.base0E, guibg='',       gui='none', guisp=''})
  H.hi('Delimiter',    {guifg=p.base0F, guibg='',       gui='', guisp=''})
  H.hi('Float',        {guifg=p.base09, guibg='',       gui='',     guisp=''})
  H.hi('Function',     {guifg=p.base0D, guibg='',       gui='',     guisp=''})
  H.hi('Identifier',   {guifg=p.base08, guibg='',       gui='none', guisp=''})
  H.hi('Include',      {guifg=p.base0D, guibg='',       gui='',     guisp=''})
  H.hi('Keyword',      {guifg=p.base0E, guibg='',       gui='',     guisp=''})
  H.hi('Label',        {guifg=p.base0A, guibg='',       gui='',     guisp=''})
  H.hi('Number',       {guifg=p.base09, guibg='',       gui='',     guisp=''})
  H.hi('Operator',     {guifg=p.base05, guibg='',       gui='', guisp=''})
  H.hi('PreProc',      {guifg=p.base0A, guibg='',       gui='',     guisp=''})
  H.hi('Repeat',       {guifg=p.base0A, guibg='',       gui='',     guisp=''})
  H.hi('Special',      {guifg=p.base0C, guibg='',       gui='',     guisp=''})
  H.hi('SpecialChar',  {guifg=p.base0F, guibg='',       gui='',     guisp=''})
  H.hi('Statement',    {guifg=p.base08, guibg='',       gui='',     guisp=''})
  H.hi('StorageClass', {guifg=p.base0A, guibg='',       gui='',     guisp=''})
  H.hi('String',       {guifg=p.base0B, guibg='',       gui='',     guisp=''})
  H.hi('Structure',    {guifg=p.base0E, guibg='',       gui='',     guisp=''})
  H.hi('Tag',          {guifg=p.base0A, guibg='',       gui='',     guisp=''})
  H.hi('Todo',         {guifg=p.base0A, guibg=p.base01, gui='',     guisp=''})
  H.hi('Type',         {guifg=p.base0A, guibg='',       gui='none', guisp=''})
  H.hi('Typedef',      {guifg=p.base0A, guibg='',       gui='',     guisp=''})

  -- Git diff
  H.hi("DiffAdded",   {guifg=p.base0B, guibg=p.base00, gui="", guisp=""})
  H.hi("DiffFile",    {guifg=p.base08, guibg=p.base00, gui="", guisp=""})
  H.hi("DiffNewFile", {guifg=p.base0B, guibg=p.base00, gui="", guisp=""})
  H.hi("DiffLine",    {guifg=p.base0D, guibg=p.base00, gui="", guisp=""})
  H.hi("DiffRemoved", {guifg=p.base08, guibg=p.base00, gui="", guisp=""})

  -- Git commit
  H.hi("gitcommitOverflow",      {guifg=p.base08, guibg="", gui="",     guisp=""})
  H.hi("gitcommitSummary",       {guifg=p.base0B, guibg="", gui="",     guisp=""})
  H.hi("gitcommitComment",       {guifg=p.base03, guibg="", gui="",     guisp=""})
  H.hi("gitcommitUntracked",     {guifg=p.base03, guibg="", gui="",     guisp=""})
  H.hi("gitcommitDiscarded",     {guifg=p.base03, guibg="", gui="",     guisp=""})
  H.hi("gitcommitSelected",      {guifg=p.base03, guibg="", gui="",     guisp=""})
  H.hi("gitcommitHeader",        {guifg=p.base0E, guibg="", gui="",     guisp=""})
  H.hi("gitcommitSelectedType",  {guifg=p.base0D, guibg="", gui="",     guisp=""})
  H.hi("gitcommitUnmergedType",  {guifg=p.base0D, guibg="", gui="",     guisp=""})
  H.hi("gitcommitDiscardedType", {guifg=p.base0D, guibg="", gui="",     guisp=""})
  H.hi("gitcommitBranch",        {guifg=p.base09, guibg="", gui="bold", guisp=""})
  H.hi("gitcommitUntrackedFile", {guifg=p.base0A, guibg="", gui="",     guisp=""})
  H.hi("gitcommitUnmergedFile",  {guifg=p.base08, guibg="", gui="bold", guisp=""})
  H.hi("gitcommitDiscardedFile", {guifg=p.base08, guibg="", gui="bold", guisp=""})
  H.hi("gitcommitSelectedFile",  {guifg=p.base0B, guibg="", gui="bold", guisp=""})

  -- Built-in LSP (similar to spelling)
  H.hi('LspDiagnosticsDefaultError',       {guifg=p.base08, guibg=p.base00, gui='', guisp=''})
  H.hi('LspDiagnosticsDefaultWarning',     {guifg=p.base0E, guibg=p.base00, gui='', guisp=''})
  H.hi('LspDiagnosticsDefaultInformation', {guifg=p.base0C, guibg=p.base00, gui='', guisp=''})
  H.hi('LspDiagnosticsDefaultHint',        {guifg=p.base0D, guibg=p.base00, gui='', guisp=''})

  H.hi('LspDiagnosticsUnderlineError',       {guifg='', guibg='', gui='underline', guisp=p.base08})
  H.hi('LspDiagnosticsUnderlineWarning',     {guifg='', guibg='', gui='underline', guisp=p.base0E})
  H.hi('LspDiagnosticsUnderlineInformation', {guifg='', guibg='', gui='underline', guisp=p.base0C})
  H.hi('LspDiagnosticsUnderlineHint',        {guifg='', guibg='', gui='underline', guisp=p.base0D})

  -- Plugins
  ---- 'mini'
  H.hi('MiniTablineCurrent',         {guifg=p.base04, guibg=p.base03, gui='bold'})
  H.hi('MiniTablineActive',          {guifg=p.base04, guibg=p.base01, gui='bold'})
  H.hi('MiniTablineHidden',          {guifg=p.base05, guibg=p.base01, gui=''})
  H.hi('MiniTablineModifiedCurrent', {guifg=p.base02, guibg=p.base0D, gui='bold'})
  H.hi('MiniTablineModifiedActive',  {guifg=p.base02, guibg=p.base0C, gui='bold'})
  H.hi('MiniTablineModifiedHidden',  {guifg=p.base03, guibg=p.base0C, gui=''})
  vim.cmd([[hi MiniTablineFill NONE]])

  H.hi('MiniStatuslineModeNormal',  {guifg=p.base00, guibg=p.base05, gui='bold'})
  H.hi('MiniStatuslineModeInsert',  {guifg=p.base00, guibg=p.base0C, gui='bold'})
  H.hi('MiniStatuslineModeVisual',  {guifg=p.base00, guibg=p.base0A, gui='bold'})
  H.hi('MiniStatuslineModeReplace', {guifg=p.base00, guibg=p.base0E, gui='bold'})
  H.hi('MiniStatuslineModeCommand', {guifg=p.base00, guibg=p.base08, gui='bold'})
  H.hi('MiniStatuslineModeOther',   {guifg=p.base00, guibg=p.base03, gui='bold'})

  H.hi('MiniTrailspace', {guifg=p.base00, guibg=p.base08})
end

function MiniColors.mini16_palette(background, foreground)
  if not (H.is_hex(background) and H.is_hex(foreground)) then return nil end
  local back, fore = H.hex_to_hsl(background), H.hex_to_hsl(foreground)

  local palette = {}

  -- First four colors are 'background': have same hue and saturation as
  -- `background`, but lightness progresses towards middle
  vim.list_extend(palette, H.make_lightness_scale(back, fore.lightness))
  -- Second four colors are 'foreground': have same hue and saturation as
  -- `foreground`, but lightness progresses towards middle
  vim.list_extend(palette, H.make_lightness_scale(fore, back.lightness))

  -- Eight accent colors are generated as pairs:
  -- - Each pair has same hue from set of hues 'most different' to background
  --   and foreground hues.
  -- - Within pair there is base lightness (equal to foreground lightness) and
  --   alternative (as middle lightness between foreground and background).
  -- - All colors have the same saturation as foreground (as they will appear
  --   next to each other).
  local middle_lightness = 0.5 * (fore.lightness + back.lightness)
  local accent_hues = H.make_different_hues({back.hue, fore.hue}, 4)
  for _, hue in pairs(accent_hues) do
    local base = {hue = hue, saturation = fore.saturation, lightness = fore.lightness}
    local alt  = {hue = hue, saturation = fore.saturation, lightness = middle_lightness}
    vim.list_extend(palette, {H.hsl_to_hex(base), H.hsl_to_hex(alt)})
  end

  -- Name colors according to base16
  local base16 = {}
  for i, hex in ipairs(palette) do
    local name = 'base' .. string.format('%02X', i - 1)
    base16[name] = hex
  end

  return base16
end

-- Helpers
---- Highlighting
function H.hi(group, args)
  local args_list = {}
  for k, v in pairs(args) do
    if v ~= '' then table.insert(args_list, k .. '=' .. v) end
  end
  local args_string = table.concat(args_list, ' ')

  local command = string.format('highlight %s %s', group, args_string)
  vim.cmd(command)
end

---- Optimal scales
---- Make a set of equally spaced hues which are as different to present hues
---- as possible
function H.make_different_hues(present_hues, n)
  local max_offset = math.floor(360 / n + 0.5) - 1
  local best_dist = -math.huge
  local cur_dist, dist, p_dist
  local best_hues, new_hues

  for offset=0,max_offset,1 do
    new_hues = H.make_hue_scale(n, offset)

    -- Compute distance as usual 'minimum distance' between two sets
    dist = H.dist_set(new_hues, present_hues)

    -- Decide if it is the best
    if dist > best_dist then
      best_hues, best_dist = new_hues, dist
    end
  end

  return best_hues
end

function H.make_hue_scale(n, offset)
  local res, step = {}, math.floor(360 / n + 0.5)
  for i=0,n-1,1 do table.insert(res, (offset + i * step) % 360) end
  return res
end

function H.make_lightness_scale(base, opposite_lightness)
  local middle = 0.5 * (base.lightness + opposite_lightness)
  local h = (middle - base.lightness) / 3

  local res = {}
  for i=0,3,1 do
    local l = base.lightness + i * h
    local hsl = {hue = base.hue, saturation = base.saturation, lightness = l}
    table.insert(res, H.hsl_to_hex(hsl))
  end

  return res
end

---- Color conversion
function H.hex_to_rgb(hex)
  if not H.is_hex(hex) then return nil end

  local dec = tonumber(hex:sub(2), 16)

  local blue = math.fmod(dec, 256)
  local green = math.fmod((dec - blue) / 256, 256)
  local red = math.floor(dec / 65536)

  return {red = red, green = green, blue = blue}
end

function H.rgb_to_hex(rgb)
  if not H.is_rgb(rgb) then return nil end

  local dec = 65536 * rgb.red + 256 * rgb.green + rgb.blue
  return string.format('#%06x', dec)
end

------ Source: https://en.wikipedia.org/wiki/HSL_and_HSV#From_RGB
function H.rgb_to_hsl(rgb)
  if not H.is_rgb(rgb) then return nil end

  local r, g, b = rgb.red / 255, rgb.green / 255, rgb.blue / 255
  local m, M = math.min(r, g, b), math.max(r, g, b)
  local chroma = M - m

  local l = 0.5 * (m + M)

  local s = 0
  if l ~= 0 and l ~= 1 then s = (M - l) / math.min(l, 1 - l) end

  local h
  if chroma == 0 then
    h = 0
  elseif M == r then
    h = 60 * (0 + (g - b) / chroma)
  elseif M == g then
    h = 60 * (2 + (b - r) / chroma)
  elseif M == b then
    h = 60 * (4 + (r - g) / chroma)
  end
  if h < 0 then h = h + 360 end

  return {hue = h, saturation = s, lightness = l}
end

function H.hsl_to_rgb(hsl)
  if not H.is_hsl(hsl) then return nil end

  local f = function(n)
    local k = math.fmod(n + hsl.hue / 30, 12)
    local a = hsl.saturation * math.min(hsl.lightness, 1 - hsl.lightness)
    local m = math.min(k - 3, 9 - k, 1)
    return hsl.lightness - a * math.max(-1, m)
  end

  return {
    -- Add 0.5 to make crude rounding and not floor
    red = math.floor(255 * f(0) + 0.5),
    green = math.floor(255 * f(8) + 0.5),
    blue = math.floor(255 * f(4) + 0.5)
  }
end

function H.hex_to_hsl(hex)
  if not H.is_hex(hex) then return nil end
  return H.rgb_to_hsl(H.hex_to_rgb(hex))
end

function H.hsl_to_hex(hsl)
  if not H.is_hsl(hsl) then return nil end
  return H.rgb_to_hex(H.hsl_to_rgb(hsl))
end

function H.is_hex(x)
  return type(x) == 'string' and x:len() == 7 and
    x:sub(1, 1) == '#' and (tonumber(x:sub(2), 16) ~= nil)
end

function H.is_rgb(x)
  return type(x) == 'table' and
    type(x.red) == 'number' and 0 <= x.red and x.red <= 255 and
    type(x.green) == 'number' and 0 <= x.green and x.green <= 255 and
    type(x.blue) == 'number' and 0 <= x.blue and x.blue <= 255
end

function H.is_hsl(x)
  return type(x) == 'table' and
    type(x.hue) == 'number' and 0 <= x.hue and x.hue <= 360 and
    type(x.saturation) == 'number' and 0 <= x.saturation and x.saturation <= 1 and
    type(x.lightness) == 'number' and 0 <= x.lightness and x.lightness <= 1
end

---- Distances
function H.dist_circle(x, y)
  local d = math.abs(x - y) % 360
  return d > 180 and 360 - d or d
end

function H.dist_set(set1, set2)
  local dist = math.huge
  local d
  for _, x in pairs(set1) do
    for _, y in pairs(set2) do
      d = H.dist_circle(x, y)
      if dist > d then dist = d end
    end
  end
  return dist
end

return MiniColors
